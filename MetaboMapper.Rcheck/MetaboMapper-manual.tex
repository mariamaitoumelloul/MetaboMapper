\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `MetaboMapper'}}
\par\bigskip{\large \today}
\end{center}
\inputencoding{utf8}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {MetaboMapper: Metabolite Label Harmonization Tool}}}{}
\begin{description}
\raggedright{}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Metabolite Label Harmonization Tool}
\item[Version]\AsIs{0.0.1}
\item[Author]\AsIs{person(``Mariam'', ``Ait Oumelloul'', email = ``mariam.aitoumelloul@epfl.ch'', role = c(``cre'',``aut'')),
person(``Tancredi'', ``Guido Cogne'', role = ``ctb''))}
\item[Maintainer]\AsIs{The package maintainer }\email{mariam.aitoumelloul@epfl.ch}\AsIs{}
\item[Description]\AsIs{A package designed for metabolite label matching, offering functions to map names or identifiers (e.g., HMDB, KEGG, CHEBI, INCHIKEY) to standardized HMDB identifiers. This facilitates the integration of datasets from diverse studies with varying annotations.}
\item[License]\AsIs{MIT + file LICENSE}
\item[URL]\AsIs{}\url{https://github.com/mariamaitoumelloul/MetaboMapper}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/mariamaitoumelloul/MetaboMapper/issues}\AsIs{}
\item[Depends]\AsIs{R (>= 4.3.0)}
\item[Imports]\AsIs{dplyr, tidyr, xml2, pbapply, rlang, stats}
\item[Encoding]\AsIs{UTF-8}
\item[RoxygenNote]\AsIs{7.3.2}
\item[NeedsCompilation]\AsIs{no}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{clean\_hmdb\_data}{Clean and Process HMDB Data}{clean.Rul.hmdb.Rul.data}
\keyword{internal}{clean\_hmdb\_data}
%
\begin{Description}
Cleans and prepare the HMDB dataset by converting all columns to character, replacing NAs with empty strings,
removing unnecessary characters, and creating needed columns for the next steps.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
clean_hmdb_data(data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Dataframe generated by the first steps of hmdbextract function
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Processed dataframe for the next steps.
\end{Value}
\inputencoding{utf8}
\HeaderA{extract\_highest\_star}{Extract Highest Star}{extract.Rul.highest.Rul.star}
\keyword{internal}{extract\_highest\_star}
%
\begin{Description}
Identifies and extracts the substring(s) with the highest number
of trailing asterisks (`*`) from a delimited input string.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
extract_highest_star(s)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{s}] A string where items are delimited by `//`, each possibly ending with
one or more trailing asterisks (`*`).
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- The input string is split into individual items based on the `//` delimiter.
- Each item is checked for trailing asterisks using a regular expression.
- The function identifies the item(s) with the maximum number of trailing asterisks.
- If multiple items tie for the highest count, they are concatenated using `/`.
\end{Details}
%
\begin{Value}
A single string containing the substring(s) with the highest number
of trailing asterisks, separated by `/` if there are ties.
\end{Value}
\inputencoding{utf8}
\HeaderA{final\_label\_dataframe}{Generate a Final Labeled Dataframe}{final.Rul.label.Rul.dataframe}
\keyword{internal}{final\_label\_dataframe}
%
\begin{Description}
This function processes an input dataset  by combining and selecting
relevant columns (identifiers with highest confidence levels)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
final_label_dataframe(data_input, details = FALSE, original_name = "")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data\_input}] A data frame containing input data with columns for accession and name information.

\item[\code{details}] Logical, indicating whether to include all details in the output. If `TRUE`, the entire dataframe is returned
with renamed columns for clarity. If `FALSE`, only selected columns are returned.

\item[\code{original\_name}] A character string representing the column name in the input data that identifies the original study.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The function performs the following steps:
1. Identifies columns starting with `"accession\_in\_reference"` and `"name\_in\_reference"`.
2. Creates new columns `HMDB\_id\_list` and `HMDB\_name\_list` by combining unique, non-NA values from the identified columns.
3. Extracts the highest confidence level (based on the number of stars) for `HMDB\_id` and `HMDB\_label` using the
`extract\_highest\_star` function.
4. Calculates the number of stars (`Num\_Stars`) for the label and maps star counts to corresponding confidence levels.
5. Depending on the `details` parameter, either the full processed dataframe or a subset with selected columns is returned.
\end{Details}
%
\begin{Value}
A data frame with the final processed results:
- If `details = TRUE`, all processed columns are returned with renamed columns for clarity.
- If `details = FALSE`, a subset with columns for the original study name, HMDB label, HMDB identifier, and confidence level
is returned.
\end{Value}
\inputencoding{utf8}
\HeaderA{hmdbextract}{Extract Information of interest from HMDB XML File}{hmdbextract}
%
\begin{Description}
Reads an HMDB XML file and extracts metabolite-related information into a structured data frame.
This includes metabolite identifiers, taxonomy, and external references.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hmdbextract(in_file)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{in\_file}] A character string specifying the path to the HMDB XML file.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
This function parses an HMDB XML file. It iterates through each metabolite
node, extracts relevant fields, and returns the information as a data frame.
\end{Details}
%
\begin{Value}
A data frame containing extracted metabolite information with the following columns:
\begin{itemize}

\item{} \code{accession}: Primary accession ID.
\item{} \code{secondary\_accessions}: Secondary accession IDs, concatenated into a single string.
\item{} \code{name}: Name of the metabolite.
\item{} \code{description}: Description of the metabolite.
\item{} \code{synonyms}: Synonyms for the metabolite, concatenated into a single string.
\item{} \code{InChIKey}: InChIKey of the metabolite.
\item{} \code{description\_taxonomy}: Description of the taxonomy.
\item{} \code{kingdom}: Taxonomic kingdom classification.
\item{} \code{super\_class}: Taxonomic super class.
\item{} \code{class}: Taxonomic class.
\item{} \code{sub\_class}: Taxonomic subclass.
\item{} \code{direct\_parent}: Taxonomic direct parent classification.
\item{} \code{chebi\_id}: ChEBI ID of the metabolite.
\item{} \code{kegg\_id}: KEGG ID of the metabolite.

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  # Example usage
  extracted_data <- hmdbextract("path_to_hmdb.xml")
  head(extracted_data)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{mapper\_confidence\_level}{Mapper Confidence Level}{mapper.Rul.confidence.Rul.level}
\keyword{internal}{mapper\_confidence\_level}
%
\begin{Description}
Based on which the mapping strategy, give a confidence level for the metabolite annotation
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mapper_confidence_level(data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] A data frame containing metabolite identifiers to be updated with confidence score.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- Columns ending with `\_HMDB`, `\_inchikey`, `\_NAME`, `\_KEGG`, or `\_CHEBI` are appended with `***`.
- Columns ending with `\_skeleton` are appended with `**`.
- Non-character columns matching the patterns are skipped with a warning.

modified\_df <- mapper\_confidence\_level(df)
\end{Details}
%
\begin{Value}
A modified data frame where selected identifier columns with corresponding confidence level.
\end{Value}
\inputencoding{utf8}
\HeaderA{map\_unique\_identifier}{Map Unique Identifiers}{map.Rul.unique.Rul.identifier}
\keyword{internal}{map\_unique\_identifier}
%
\begin{Description}
Maps a given metabolite identifier type in a cohort data frame to reference identifiers
(e.g., INCHIKEY, NAME, HMDB, CHEBI, KEGG) by performing a series of processing, matching,
and reporting steps.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_unique_identifier(df_cohort, col_cohort, df_reference, identifier)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df\_cohort}] A data frame containing cohort data with metabolite identifiers to be mapped.

\item[\code{col\_cohort}] A character string specifying the column in `df\_cohort` containing the identifier to be mapped.

\item[\code{df\_reference}] A data frame containing reference data with metabolite identifiers and corresponding metadata.

\item[\code{identifier}] A character string specifying the type of identifier to map.
Supported values are `"INCHIKEY"`, `"NAME"`, `"HMDB"`, `"CHEBI"`, and `"KEGG"`.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- For `INCHIKEY`, both the full and skeleton INCHIKEY identifiers are mapped.
- For `NAME`, metabolite names are processed and matched to all known labels, inclusing synonyms.
- For `HMDB`, `CHEBI`, and `KEGG`, the corresponding identifiers are matched directly to reference identifiers.
\end{Details}
%
\begin{Value}
A data frame with updated mapping information, including matched identifiers
\end{Value}
\inputencoding{utf8}
\HeaderA{match\_identifier}{Match Identifier}{match.Rul.identifier}
\keyword{internal}{match\_identifier}
%
\begin{Description}
Matches metabolite identifiers from a cohort data set with a reference database,
annotating the matches and providing additional information.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
match_identifier(
  df_cohort,
  col_cohort,
  df_reference,
  col_reference,
  identifier
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df\_cohort}] A data frame containing cohort data with metabolite identifiers to be mapped.

\item[\code{col\_cohort}] A character string specifying the column in `df\_cohort` containing the identifier to be mapped.

\item[\code{df\_reference}] A data frame containing reference data with metabolite identifiers and corresponding metadata.

\item[\code{identifier}] A character string specifying the type of identifier to map.
Supported values are `"INCHIKEY"`, `"NAME"`, `"HMDB"`, `"CHEBI"`, and `"KEGG"`.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- Counts and prints the number of available identifiers in the cohort data set before matching.
- Renames columns in the reference data frame by appending `"\_in\_reference\_"` and the `identifier`
to avoid naming conflicts.
- Merges the cohort and reference data frames based on the specified identifier columns.
- Adds a new logical column (`mapped\_to\_<col\_reference>`) to indicate if a match was found.
\end{Details}
%
\begin{Value}
A data frame that merges the cohort and reference data frames based on the specified identifier.Includes an additional column indicating whether a match was found.
\end{Value}
\inputencoding{utf8}
\HeaderA{MetaboMap}{MetaboMap}{MetaboMap}
%
\begin{Description}
Maps multiple identifiers from a study data frame to a reference data frame by iterating through corresponding identifier and study column pairs. Ensures data integrity, applies mapping functions, and adds confidence levels and labels.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
MetaboMap(
  df_study,
  study_cols,
  identifiers,
  df_reference,
  details = FALSE,
  original_name = ""
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df\_study}] A data frame representing the study data containing metabolites information to be processed.

\item[\code{study\_cols}] A column name or a vector of column names in `df\_study` corresponding to identifiers to be mapped.

\item[\code{identifiers}] An identifier or a vector of identifiers to be mapped; must be the same length and same order as `study\_cols`. It can takes values c("HMDB","NAME","KEGG","CHEBI","INCHIKEY")

\item[\code{df\_reference}] Dataframe generated by the function hmdbextract().

\item[\code{details}] A boolean- Default Value is FALSE. TRUE allows to have additional details for each mapping identifier.

\item[\code{original\_name}] The original name of the data or dataset for labeling purposes. Default value is "study".
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame object containing the mapped identifiers with confidence levels.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Example usage:
study_data <- data.frame(metabolite_name=c("M1","M2"),id1 = c(1, 2), id2 = c("A", "B"))
reference_data <- data.frame(ref_id = c(1, 2), name = c("X", "Y"))
result <- MetaboMap(
  df_study = study_data,
  study_cols = c("id1", "id2"),
  identifiers = c("ref_id", "name"),
  df_reference = reference_data,
  details = FALSE,
  original_name = "metabolite_name"
)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{process\_inchikey}{Process InChIKey}{process.Rul.inchikey}
\keyword{internal}{process\_inchikey}
%
\begin{Description}
Processes a specified column containing InChIKey strings by extracting
the first `N\_skeleton` characters to create a skeleton InChIKey and the first `N\_inchikey` characters
to create a processed InChIKey.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
process_inchikey(df, col_name, N_skeleton = 14, N_inchikey = 23)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] A data frame containing the column with InChIKey strings.

\item[\code{col\_name}] The name of the column containing the InChIKey strings to be processed.

\item[\code{N\_skeleton}] An integer specifying the number of characters to extract for the skeleton InChIKey.
Default is 14.

\item[\code{N\_inchikey}] An integer specifying the number of characters to extract for the processed InChIKey.
Default is 23.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- This function takes a column with InChIKey strings and extracts a skeleton version (first 14 characters)
and a processed version (first 23 characters) of each InChIKey.
- It returns the data frame with these new columns added.
\end{Details}
%
\begin{Value}
A data frame with two new columns:
- `inchikey\_skeleton`: A new column containing the first `N\_skeleton` characters of the specified InChIKey.
- `inchikey\_processed`: A new column containing the first `N\_inchikey` characters of the specified InChIKey.
\end{Value}
\inputencoding{utf8}
\HeaderA{process\_labels}{Process Labels}{process.Rul.labels}
\keyword{internal}{process\_labels}
%
\begin{Description}
Cleans and standardizes labels by removing spaces, dashes, uppercase letters,
special characters (such as single and double quotes, asterisks), and numbers in parentheses at the end of the label.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
process_labels(df, col_name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] A data frame containing the labels to be processed.

\item[\code{col\_name}] The name of the column containing the labels to be processed.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- The function performs several text cleaning operations:
- It removes spaces and dashes.
- It converts the text to lowercase.
- It removes single and double quotes, and asterisks.
- It uses an external function `remove\_letters\_between\_parentheses` to remove shorter names within parentheses.
- It also removes numeric values in parentheses at the end of the label (e.g., "(1)", "(2)").
- The cleaned labels are stored in a new column `label\_processed`.
\end{Details}
%
\begin{Value}
A data frame with a new column `label\_processed`, which contains the cleaned labels.
\end{Value}
\inputencoding{utf8}
\HeaderA{remove\_letters\_between\_parentheses}{Remove Letters Between Parentheses}{remove.Rul.letters.Rul.between.Rul.parentheses}
\keyword{internal}{remove\_letters\_between\_parentheses}
%
\begin{Description}
Removes any letters enclosed within parentheses from a given text string.
It leaves the parentheses empty or removes them entirely if they contain only letters.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
remove_letters_between_parentheses(text)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{text}] A character string containing text where letters within parentheses will be removed.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
- The function uses a regular expression to match any sequence of letters inside parentheses and replace them with empty strings.
- It ensures that parentheses without letters are also cleaned, resulting in no empty parentheses remaining.
\end{Details}
%
\begin{Value}
A character string with letters inside parentheses removed. The parentheses themselves are also removed.
\end{Value}
\inputencoding{utf8}
\HeaderA{safe\_extract}{safe\_extract}{safe.Rul.extract}
\keyword{internal}{safe\_extract}
%
\begin{Description}
Extracts the text content from an XML node using the specified XPath expression and namespace. Returns "NA" if an error occurs during extraction.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
safe_extract(xml_node, xpath, ns)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{xml\_node}] An XML node object from which to extract content.

\item[\code{xpath}] A character string specifying the XPath expression to locate the desired element within the XML node.

\item[\code{ns}] A named list of namespace definitions to use when resolving the XPath expression.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A character string containing the extracted text content. Returns "NA" if the specified XPath cannot be resolved or an error occurs.
\end{Value}
\printindex{}
\end{document}
